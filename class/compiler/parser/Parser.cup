package compiler.parser;

import java_cup.runtime.*;
import compiler.scanner.Scanner;
import java.io.FileReader;
import java.io.IOException;
import java.io.FileWriter;
import java.io.PrintWriter;

parser code {:
    private Scanner scanner;

    public Parser(Scanner scanner) {
        super(scanner);
        this.scanner = scanner;
    }

    @Override
    public Symbol scan() throws Exception {
        return scanner.next_token();
    }

    @Override
    public void syntax_error(Symbol s) {
        String tokenName = (s.sym >= 0 && s.sym < sym.terminalNames.length) ? sym.terminalNames[s.sym] : "UNKNOWN";
        String tokenValue = s.value == null ? "" : s.value.toString();
        String errorMessage = String.format(
            "Error Sintáctico en la Línea %d, Columna %d: Token '%s' no reconocido. Tipo: %s",
            s.left + 1, s.right + 1, tokenValue, tokenName
        );

        // Escribir en el archivo output.txt
        writeToFile(errorMessage);

        // Imprimir en la consola
        System.err.println(errorMessage);
    }

    private void writeToFile(String message) {
        try (PrintWriter out = new PrintWriter(new FileWriter("output.txt", true))) {
            out.println(message);
        } catch (IOException e) {
            System.err.println("Error al escribir en el archivo de salida: " + e.getMessage());
        }
    }
:};

/* Declaraciones de terminales */
terminal CLASS, INT, VOID, DOUBLE, BOOLEAN, STRING, INTERFACE, NULL, THIS;
terminal EXTENDS, IMPLEMENTS, FOR, WHILE, IF, ELSE, RETURN, BREAK, NEW, NEWARRAY;
terminal PRINT, READINTEGER, READLINE, TRUE, FALSE, CALLOUT;

terminal ASSIGN, EQ, NEQ, LT, LE, GT, GE, AND, OR, NOT;
terminal PLUS, MINUS, MULTIPLY, DIVIDE, MOD;
terminal SEMI, COMMA, DOT;
terminal LBRACE, RBRACE, LPAREN, RPAREN, LBRACKET, RBRACKET;

terminal String ID;
terminal Integer INT_LITERAL;
terminal String STRING_LITERAL;

/* Declaraciones de no terminales */
non terminal program, class_decl, method_decl, var_decl, type;
non terminal statement, expr, param_list, arg_list;
non terminal class_body_member_list, class_body_member, field_decl, block;
non terminal block_item_list, block_item, decl, decl_no_semi, init_declarator_list, init_declarator, assignment;
non terminal arg_list_non_empty, callout_arg_list, callout_arg;

/* Precedencias */
precedence left OR;
precedence left AND;
precedence left EQ, NEQ;
precedence left LT, LE, GT, GE;
precedence left PLUS, MINUS;
precedence left MULTIPLY, DIVIDE, MOD;
precedence right NOT;
precedence right ASSIGN;

/* Símbolo de inicio */
start with program;

/* Reglas gramaticales */
program ::= class_decl ;

class_decl ::= CLASS ID LBRACE class_body_member_list RBRACE ;

class_body_member_list ::=
      class_body_member_list class_body_member
    | /* vacío */ ;

class_body_member ::=
      field_decl
    | method_decl ;

field_decl ::= decl ;

method_decl ::= type ID LPAREN param_list RPAREN block ;

param_list ::=
      param_list COMMA type ID
    | type ID
    | /* vacío */ ;

block ::= LBRACE block_item_list RBRACE ;

block_item_list ::=
      block_item_list block_item
    | /* vacío */ ;

block_item ::=
      decl
    | statement ;

decl ::= type init_declarator_list SEMI ;

decl_no_semi ::= type init_declarator_list ;

init_declarator_list ::=
      init_declarator
    | init_declarator_list COMMA init_declarator ;

init_declarator ::=
      ID
    | ID ASSIGN expr ;

statement ::=
      assignment SEMI
    | expr SEMI
    | IF LPAREN expr RPAREN block
    | IF LPAREN expr RPAREN block ELSE block
    | FOR LPAREN decl_no_semi SEMI expr SEMI assignment RPAREN block
    | RETURN expr SEMI
    | block ;

assignment ::= ID ASSIGN expr ;

expr ::=
      expr PLUS expr
    | expr MINUS expr
    | expr MULTIPLY expr
    | expr DIVIDE expr
    | expr MOD expr
    | expr LT expr
    | expr LE expr
    | expr GT expr
    | expr GE expr
    | expr EQ expr
    | expr NEQ expr
    | expr AND expr
    | expr OR expr
    | NOT expr %prec NOT
    | MINUS expr %prec NOT /* operador unario menos */
    | ID
    | INT_LITERAL
    | TRUE
    | FALSE
    | STRING_LITERAL
    | ID LPAREN arg_list RPAREN
    | CALLOUT LPAREN STRING_LITERAL callout_arg_list RPAREN
    | LPAREN expr RPAREN ;

arg_list ::=
      arg_list_non_empty
    | /* vacío */ ;

arg_list_non_empty ::=
      arg_list_non_empty COMMA expr
    | expr ;

callout_arg_list ::=
      callout_arg_list COMMA callout_arg
    | callout_arg
    | /* vacío */ ;

callout_arg ::=
      expr
    ;

/* Definición de tipo */
type ::=
      INT
    | VOID
    | BOOLEAN
    | DOUBLE
    | STRING ;